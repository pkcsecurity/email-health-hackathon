(-main)
(defn a [] (use 'email-health-hackathon.core :reload-all))
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(a)
(-main)
(a)
(-main)
(a)
(-main)
(defn c [] (a) (-main))
(c)
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
:keys ["a" "b"]
(:keys ["a" "b"])
(keys ["a" "b"])
(zipmap ["1" "2"] ["a" "b"])
(key "a")
(:key "a")
(keyword "a")
(c)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(= false 0)
(= false nil)
(false? nil)
(true? nil)
(nil? nil)
(not-nil? nil)
(c)
(update {} :a inc)
(update {:a 1} :a inc)
(c)
(when true 1)
(when true (let [x (+ 1 2)] (when true 1)))
(when true (let [x (+ 1 2)] (when true 2)))
(when true (let [x (+ 1 2)] (when true )))
(when true (let [x (+ 1 2)] (when true x)))
(c)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
exit
(-main)
(first {:a {:a 1 :b 2}})
(first {:a {:a 1 :b 2} :b 2})
(-main)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(defn median [coll]
  (let [sorted (sort coll)
        cnt (count sorted)
        halfway (quot cnt 2)]
    (if (odd? cnt)
      (nth sorted halfway) ; (1)
      (let [bottom (dec halfway)
            bottom-val (nth sorted bottom)
            top-val (nth sorted halfway)]
        (mean [bottom-val top-val]))))) ; (2)
(c)
exit
exit 
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
exit
(-main)
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
AAclojure.string/split ";" ";"
clojure.string/split ";" ";"
count (clojure.string/split ";" ";")
(count (clojure.string/split ";" #";"))
(count (clojure.string/split "a;a" #";"))
(count (clojure.string/split "a;" #";"))
(c)
(< 10 9)
(c)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
exit
(def e "Levi931262@msnpath.com##Receive, Deliver;Tim263708@msnpath.com##Receive, Deliver;")
(mapv first (mapv s/split (s/split e #";") #"##"))
(mapv first (mapv clojure.string/split (s/split e #";") #"##"))
(mapv first (mapv clojure.string/split (clojure.string/split e #";") #"##"))
(mapv first (mapv #(clojure.string/split % #"##") (clojure.string/split e #";")))
(conj (mapv first (mapv #(clojure.string/split % #"##") (clojure.string/split e #";"))) "AAAA12323@gmail.com")
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(contains? [1 2 3] 1)
(contains? ["1" "2" "3"] "1")
(contains? [1 2 3] 4)
(contains? [1 2 3] 3)
(contains? [1 2 3] 2)
(contains? [1 2 3] 1)
(c)
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(f/show-formatters)
(clj-time.format/show-formatters)
(c)
exit
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(apply + [1 2] [3 4])
(mapv [1 2] [3 4])
(map vector [1 2] [3 4])
(c)
exit
(-main)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
exit
(-main)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(butlast [1 2 3])
(rest [1 2 3])
(c)
exit
(-main)
(defn a [] (use 'email-health-hackathon.core :reload-all))
(defn c [] (a) (-main))
(c)
(hashmap #{"a" "b" "c"}
)
(into {} #{1 2 3})
(reduce (fn [acc x] (assoc acc x [])) {} #{1 2 3})
(c)
